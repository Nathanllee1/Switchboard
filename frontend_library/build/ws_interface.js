var o,p=new Uint8Array(16);function l(){if(!o&&(o=typeof crypto!="undefined"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto!="undefined"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!o))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return o(p)}var g=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function b(t){return typeof t=="string"&&g.test(t)}var n=[];for(var u=0;u<256;++u)n.push((u+256).toString(16).substr(1));function f(t){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,s=(n[t[e+0]]+n[t[e+1]]+n[t[e+2]]+n[t[e+3]]+"-"+n[t[e+4]]+n[t[e+5]]+"-"+n[t[e+6]]+n[t[e+7]]+"-"+n[t[e+8]]+n[t[e+9]]+"-"+n[t[e+10]]+n[t[e+11]]+n[t[e+12]]+n[t[e+13]]+n[t[e+14]]+n[t[e+15]]).toLowerCase();if(!b(s))throw TypeError("Stringified UUID is invalid");return s}function h(t,e,s){t=t||{};var i=t.random||(t.rng||l)();if(i[6]=i[6]&15|64,i[8]=i[8]&63|128,e){s=s||0;for(var r=0;r<16;++r)e[s+r]=i[r];return e}return f(i)}var a=class{constructor(){this.cb=()=>{}}onMessage(e){this.cb=e}pushMessage(e){this.cb(e)}};var d=class{constructor(){this.promise=new Promise((e,s)=>{this.reject=s,this.resolve=e})}},c=class{constructor(e){this.gets={},this.pending_subs={},this.subs={},this.url=e}async initialize(){return this.ws_interface=new WebSocket(this.url),this.ws_interface.addEventListener("message",e=>{this.handle_message(e.data)}),new Promise((e,s)=>{this.ws_interface.addEventListener("open",()=>{e(null)})})}get(e,s={}){let i=h();this.ws_interface.send(JSON.stringify({type:"GET",body:{path:e,uuid:i,args:s}}));let r=new d;return this.gets[i]=r,r.promise}handle_message(e){let s=JSON.parse(e);switch(s.type){case"GET":this.handle_get_return(s.body);break;case"SUBSCRIPTION_STATUS":this.handle_sub_return(s.body);break;case"SUBSCRIPTION_PUSH":this.handle_push(s.body);break;default:throw`Message type ${s.type} not valid`}}handle_get_return(e){this.gets[e.uuid].resolve(e.data)}subscribe(e){if(this.pending_subs[e])throw`Subscription ${e} still pending`;this.ws_interface.send(JSON.stringify({type:"SUBSCRIPTION",body:{channel:e}}));let s=new d;return this.pending_subs[e]=s,s.promise}handle_sub_return(e){if(e.connected){let s=new a;this.subs[e.sub]=s,this.pending_subs[e.sub].resolve(s),delete this.pending_subs[e.sub]}else console.error(e.status)}handle_push(e){this.subs[e.sub].pushMessage(e.data)}};export{c as WS_Interface};
//# sourceMappingURL=ws_interface.js.map
